/**
 * HTML Generator
 * Creates HTML documents with interactive forms
 */

import { writeFile, mkdir, readFile } from 'fs/promises';
import { dirname } from 'path';
import { existsSync } from 'fs';
import type {
  ParsedFormSchema,
  NormalizedFormField,
  HtmlConfig,
  SchemaContentElement,
  HeadingContent,
  ParagraphContent,
  FieldContent,
  TableContent,
  AdmonitionContent,
  SpacerContent,
  TableColumn,
  FieldOption,
} from '../../types/index.js';
import { DEFAULT_CONFIG } from '../../types/index.js';
import type { ParsedMarkdown } from '../../parsers/index.js';

export interface HtmlGeneratorOptions {
  markdown?: ParsedMarkdown;
  schema?: ParsedFormSchema | null;
  config?: Partial<HtmlConfig>;
}

/**
 * Generate HTML document
 */
export async function generateHtml(options: HtmlGeneratorOptions): Promise<string> {
  const { markdown, schema, config = {} } = options;

  const htmlConfig: Required<HtmlConfig> = {
    ...DEFAULT_CONFIG.html,
    ...config,
  };

  let html = '';

  // Check if custom template is provided
  if (htmlConfig.template && existsSync(htmlConfig.template)) {
    html = await readFile(htmlConfig.template, 'utf-8');
    // Replace placeholders in template
    html = html.replace('{{title}}', markdown?.title ?? schema?.form.title ?? 'Document');
    html = html.replace('{{content}}', markdown?.html ?? '');
    if (schema) {
      html = html.replace('{{form}}', generateFormHtml(schema));
    }
  } else {
    // Generate default HTML
    html = generateDefaultHtml(markdown, schema, htmlConfig);
  }

  return html;
}

/**
 * Generate default HTML document
 */
function generateDefaultHtml(
  markdown: ParsedMarkdown | undefined,
  schema: ParsedFormSchema | null | undefined,
  config: Required<HtmlConfig>
): string {
  const title = markdown?.title ?? schema?.form.title ?? 'Document';

  let styles = '';
  if (config.embedStyles) {
    styles = `
    <style>
      ${getDefaultStyles()}
    </style>`;
  }

  let scripts = '';
  if (config.includeJs && schema) {
    scripts = `
    <script>
      ${getFormScripts()}
    </script>`;
  }

  const formHtml = schema ? generateFormHtml(schema) : '';
  // Use schema content if available, otherwise fall back to markdown HTML
  const contentHtml =
    schema?.content && schema.content.length > 0
      ? generateContentHtml(schema)
      : (markdown?.html ?? '');

  // If schema has content, don't wrap in form - content includes its own fields
  const hasSchemaContent = schema?.content && schema.content.length > 0;

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(title)}</title>
  ${styles}
</head>
<body>
  <div class="container">
    <header>
      <h1>${escapeHtml(title)}</h1>
      ${schema?.form.version ? `<span class="version">v${escapeHtml(schema.form.version)}</span>` : ''}
    </header>

    <main>
      ${
        hasSchemaContent
          ? `<form id="form-${schema?.form.id ?? 'main'}" class="schema-content-form">
          ${contentHtml}
          <div class="form-actions">
            <button type="submit" class="btn btn-primary">Submit</button>
            <button type="reset" class="btn btn-secondary">Reset</button>
          </div>
        </form>`
          : `${contentHtml}
      ${
        formHtml
          ? `
      <form id="form-${schema?.form.id ?? 'main'}" class="form">
        ${formHtml}
        <div class="form-actions">
          <button type="submit" class="btn btn-primary">Submit</button>
          <button type="reset" class="btn btn-secondary">Reset</button>
        </div>
      </form>
      `
          : ''
      }`
      }
    </main>

    <footer>
      <p>Generated by markdown-2pdf</p>
    </footer>
  </div>
  ${scripts}
</body>
</html>`;
}

/**
 * Generate HTML from schema content elements
 */
function generateContentHtml(schema: ParsedFormSchema): string {
  if (!schema.content || schema.content.length === 0) {
    return '';
  }

  let fieldNumber = 0;
  const enableNumbering = schema.form.numbering === true;

  return schema.content
    .map((element) => renderContentElement(element, enableNumbering, () => ++fieldNumber))
    .join('\n');
}

/**
 * Render a single content element to HTML
 */
function renderContentElement(
  element: SchemaContentElement,
  enableNumbering: boolean,
  getFieldNumber: () => number
): string {
  switch (element.type) {
    case 'heading':
      return renderHeading(element);
    case 'paragraph':
      return renderParagraph(element);
    case 'rule':
      return renderRule();
    case 'field':
      return renderInlineField(element, enableNumbering, getFieldNumber);
    case 'table':
      return renderTable(element);
    case 'admonition':
      return renderAdmonition(element);
    case 'spacer':
      return renderSpacer(element);
    default:
      return `<!-- Unknown content type: ${(element as SchemaContentElement).type} -->`;
  }
}

function renderHeading(element: HeadingContent): string {
  const level = element.level ?? 2;
  return `<h${level}>${escapeHtml(element.text)}</h${level}>`;
}

function renderParagraph(element: ParagraphContent): string {
  const style = element.maxWidth ? ` style="max-width: ${element.maxWidth}px"` : '';
  return `<p${style}>${escapeHtml(element.text)}</p>`;
}

function renderRule(): string {
  return '<hr class="content-rule" />';
}

function renderSpacer(element: SpacerContent): string {
  return `<div class="spacer" style="height: ${element.height}px"></div>`;
}

function renderAdmonition(element: AdmonitionContent): string {
  const variantClass = `admonition-${element.variant}`;
  return `
    <div class="admonition ${variantClass}">
      <div class="admonition-title">${escapeHtml(element.title)}</div>
      <div class="admonition-content">${escapeHtml(element.text)}</div>
    </div>`;
}

function renderInlineField(
  element: FieldContent,
  enableNumbering: boolean,
  getFieldNumber: () => number
): string {
  const labelPosition = element.labelPosition ?? 'above';
  const label = enableNumbering
    ? `${getFieldNumber()}. ${element.label ?? ''}`
    : (element.label ?? '');

  const containerClass =
    labelPosition === 'left' ? 'inline-field inline-field-horizontal' : 'inline-field';
  const labelStyle =
    labelPosition === 'left' && element.labelWidth
      ? ` style="width: ${element.labelWidth}px; min-width: ${element.labelWidth}px"`
      : '';
  const fieldStyle = element.width ? ` style="width: ${element.width}px"` : '';

  let fieldHtml = '';

  switch (element.fieldType) {
    case 'text':
      fieldHtml = `<input type="text" id="${element.fieldName}" name="${element.fieldName}"
        ${element.placeholder ? `placeholder="${escapeHtml(element.placeholder)}"` : ''}
        ${element.default ? `value="${escapeHtml(String(element.default))}"` : ''}
        ${element.required ? 'required' : ''}${fieldStyle}>`;
      break;

    case 'textarea': {
      const textareaStyle =
        (element.width ?? element.height)
          ? ` style="${element.width ? `width: ${element.width}px;` : ''}${element.height ? `height: ${element.height}px;` : ''}"`
          : '';
      fieldHtml = `<textarea id="${element.fieldName}" name="${element.fieldName}"
        ${element.placeholder ? `placeholder="${escapeHtml(element.placeholder)}"` : ''}
        ${element.required ? 'required' : ''}${textareaStyle}>${element.default ? escapeHtml(String(element.default)) : ''}</textarea>`;
      break;
    }

    case 'checkbox':
      fieldHtml = `<input type="checkbox" id="${element.fieldName}" name="${element.fieldName}"
        ${element.default === true ? 'checked' : ''}>`;
      break;

    case 'dropdown': {
      const options = (element.options ?? [])
        .map((opt: FieldOption | string) => {
          const optValue = typeof opt === 'string' ? opt : opt.value;
          const optLabel = typeof opt === 'string' ? opt : opt.label;
          const selected = element.default === optValue ? ' selected' : '';
          return `<option value="${escapeHtml(optValue)}"${selected}>${escapeHtml(optLabel)}</option>`;
        })
        .join('\n          ');
      fieldHtml = `<select id="${element.fieldName}" name="${element.fieldName}"
        ${element.required ? 'required' : ''}${fieldStyle}>
          <option value="">-- Select --</option>
          ${options}
        </select>`;
      break;
    }
  }

  return `
    <div class="${containerClass}">
      <label for="${element.fieldName}"${labelStyle}>${escapeHtml(label)}</label>
      ${fieldHtml}
    </div>`;
}

function renderTable(element: TableContent): string {
  const columns = element.columns;
  const rows = generateTableRows(element);

  const tableLabel = element.label
    ? `<div class="table-label">${escapeHtml(element.label)}</div>`
    : '';

  // Generate header row
  const headerCells = columns
    .map((col) => `<th style="width: ${col.width}px">${escapeHtml(col.label)}</th>`)
    .join('');
  const headerRow = `<tr>${headerCells}</tr>`;

  // Generate data rows
  const dataRows = rows
    .map((row) => {
      const cells = row
        .map((cell, colIdx) => {
          const col = columns[colIdx];
          return `<td>${renderTableCell(cell, col)}</td>`;
        })
        .join('');
      return `<tr>${cells}</tr>`;
    })
    .join('\n');

  return `
    ${tableLabel}
    <table class="content-table">
      <thead>${headerRow}</thead>
      <tbody>${dataRows}</tbody>
    </table>`;
}

interface TableCellData {
  type: 'label' | 'text' | 'dropdown' | 'checkbox';
  value?: string;
  fieldName?: string;
  options?: FieldOption[];
  default?: string | boolean;
}

function generateTableRows(element: TableContent): TableCellData[][] {
  const columns = element.columns;
  const rows: TableCellData[][] = [];

  // If rowCount is specified, generate rows from column definitions
  if (element.rowCount && element.fieldPrefix) {
    for (let rowIdx = 1; rowIdx <= element.rowCount; rowIdx++) {
      const row: TableCellData[] = columns.map((col) => {
        const cellType = col.cellType ?? 'text';
        const prefix = element.fieldPrefix ?? 'table';
        const fieldName = col.fieldSuffix
          ? `${prefix}_${rowIdx}_${col.fieldSuffix}`
          : `${prefix}_${rowIdx}_${(col.label ?? '').toLowerCase().replace(/\s+/g, '_')}`;

        if (cellType === 'label') {
          return { type: 'label', value: '' };
        }

        return {
          type: cellType,
          fieldName,
          options: col.options,
        };
      });
      rows.push(row);
    }
  }

  // If explicit rows are defined
  if (element.rows) {
    for (const row of element.rows) {
      if (row.cells) {
        // Full cell definitions
        const cellData: TableCellData[] = row.cells.map((cell) => {
          if (cell.type === 'label') {
            return { type: 'label', value: cell.value };
          }
          return {
            type: cell.type,
            fieldName: cell.fieldName,
            options: cell.options,
            default: cell.default,
          };
        });
        rows.push(cellData);
      } else if (row.values) {
        // Compact format: values array
        const cellData: TableCellData[] = row.values.map((val, colIdx) => {
          const col = columns[colIdx];
          // Handle case where values exceed column count (skip extra values)
          if (!col) {
            return { type: 'text' as const, fieldName: String(val) };
          }
          const cellType = col.cellType ?? 'text';

          if (cellType === 'label') {
            return { type: 'label' as const, value: String(val) };
          }

          // For non-label cells, the value is the fieldName
          return {
            type: cellType,
            fieldName: String(val),
            options: col.options,
          };
        });
        rows.push(cellData);
      }
    }
  }

  return rows;
}

function renderTableCell(cell: TableCellData, _col: TableColumn): string {
  switch (cell.type) {
    case 'label':
      return escapeHtml(cell.value ?? '');

    case 'text': {
      const fieldName = cell.fieldName ?? '';
      const defaultValue = cell.default ? `value="${escapeHtml(String(cell.default))}"` : '';
      return `<input type="text" name="${fieldName}" class="table-input"
        ${defaultValue}>`;
    }

    case 'checkbox': {
      const fieldName = cell.fieldName ?? '';
      return `<input type="checkbox" name="${fieldName}"
        ${cell.default === true ? 'checked' : ''}>`;
    }

    case 'dropdown': {
      const fieldName = cell.fieldName ?? '';
      const options = (cell.options ?? [])
        .map((opt) => {
          const selected = cell.default === opt.value ? ' selected' : '';
          return `<option value="${escapeHtml(opt.value)}"${selected}>${escapeHtml(opt.label)}</option>`;
        })
        .join('');
      return `<select name="${fieldName}" class="table-select">
        <option value="">--</option>
        ${options}
      </select>`;
    }

    default:
      return '';
  }
}

/**
 * Generate HTML for form fields
 */
function generateFormHtml(schema: ParsedFormSchema): string {
  const fieldsByPage = new Map<number, NormalizedFormField[]>();

  // Group fields by page
  for (const field of schema.fields) {
    const pageFields = fieldsByPage.get(field.page) ?? [];
    pageFields.push(field);
    fieldsByPage.set(field.page, pageFields);
  }

  let html = '';

  // Generate HTML for each page
  for (const [pageNum, fields] of fieldsByPage) {
    if (fieldsByPage.size > 1) {
      html += `<fieldset class="form-page" data-page="${pageNum}">\n`;
      html += `  <legend>Page ${pageNum}</legend>\n`;
    }

    for (const field of fields) {
      html += generateFieldHtml(field);
    }

    if (fieldsByPage.size > 1) {
      html += `</fieldset>\n`;
    }
  }

  return html;
}

/**
 * Generate HTML for a single field
 */
function generateFieldHtml(field: NormalizedFormField): string {
  const requiredAttr = field.required ? ' required' : '';
  const requiredMark = field.required ? '<span class="required">*</span>' : '';

  switch (field.type) {
    case 'text':
      return `
      <div class="form-group">
        <label for="${field.name}">${escapeHtml(field.label)}${requiredMark}</label>
        <input type="text" id="${field.name}" name="${field.name}"
          ${field.maxLength ? `maxlength="${field.maxLength}"` : ''}
          ${field.placeholder ? `placeholder="${escapeHtml(field.placeholder)}"` : ''}
          ${typeof field.default === 'string' ? `value="${escapeHtml(field.default)}"` : ''}
          ${field.readOnly ? 'readonly' : ''}
          ${requiredAttr}>
      </div>`;

    case 'textarea':
      return `
      <div class="form-group">
        <label for="${field.name}">${escapeHtml(field.label)}${requiredMark}</label>
        <textarea id="${field.name}" name="${field.name}"
          ${field.maxLength ? `maxlength="${field.maxLength}"` : ''}
          ${field.placeholder ? `placeholder="${escapeHtml(field.placeholder)}"` : ''}
          ${field.readOnly ? 'readonly' : ''}
          rows="5"
          ${requiredAttr}>${typeof field.default === 'string' ? escapeHtml(field.default) : ''}</textarea>
      </div>`;

    case 'checkbox':
      return `
      <div class="form-group form-check">
        <input type="checkbox" id="${field.name}" name="${field.name}"
          ${field.default === true ? 'checked' : ''}
          ${field.readOnly ? 'disabled' : ''}>
        <label for="${field.name}">${escapeHtml(field.label)}${requiredMark}</label>
      </div>`;

    case 'radio': {
      const radioOptions = (field.options ?? [])
        .map(
          (opt, index) => `
        <div class="form-check">
          <input type="radio" id="${field.name}_${index}" name="${field.name}" value="${escapeHtml(opt.value)}"
            ${field.default === opt.value ? 'checked' : ''}
            ${field.readOnly ? 'disabled' : ''}>
          <label for="${field.name}_${index}">${escapeHtml(opt.label)}</label>
        </div>`
        )
        .join('');

      return `
      <div class="form-group">
        <label>${escapeHtml(field.label)}${requiredMark}</label>
        <div class="radio-group">
          ${radioOptions}
        </div>
      </div>`;
    }

    case 'dropdown': {
      const selectOptions = (field.options ?? [])
        .map(
          (opt) =>
            `<option value="${escapeHtml(opt.value)}" ${field.default === opt.value ? 'selected' : ''}>${escapeHtml(opt.label)}</option>`
        )
        .join('\n          ');

      return `
      <div class="form-group">
        <label for="${field.name}">${escapeHtml(field.label)}${requiredMark}</label>
        <select id="${field.name}" name="${field.name}"
          ${field.readOnly ? 'disabled' : ''}
          ${requiredAttr}>
          <option value="">-- Select --</option>
          ${selectOptions}
        </select>
      </div>`;
    }

    case 'signature':
      return `
      <div class="form-group signature-field">
        <label for="${field.name}">${escapeHtml(field.label)}${requiredMark}</label>
        <div class="signature-box">
          <canvas id="${field.name}_canvas" width="400" height="100"></canvas>
          <input type="hidden" id="${field.name}" name="${field.name}">
        </div>
        <button type="button" class="btn btn-small clear-signature" data-canvas="${field.name}_canvas">Clear</button>
      </div>`;

    default: {
      const unknownType = field.type as string;
      return `<!-- Unknown field type: ${unknownType} -->`;
    }
  }
}

/**
 * Get default CSS styles
 */
function getDefaultStyles(): string {
  return `
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f5f5f5;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      background: white;
      min-height: 100vh;
    }

    header {
      margin-bottom: 2rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }

    header h1 {
      font-size: 1.75rem;
      color: #1a1a1a;
    }

    .version {
      color: #666;
      font-size: 0.875rem;
    }

    main {
      margin-bottom: 2rem;
    }

    main h2 {
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-size: 1.25rem;
      color: #333;
    }

    main p {
      margin-bottom: 1rem;
      color: #555;
    }

    .form {
      margin-top: 2rem;
    }

    .form-page {
      margin-bottom: 2rem;
      padding: 1.5rem;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
    }

    .form-page legend {
      padding: 0 0.5rem;
      font-weight: 600;
      color: #666;
    }

    .form-group {
      margin-bottom: 1.25rem;
    }

    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: #333;
    }

    .required {
      color: #dc3545;
      margin-left: 0.25rem;
    }

    input[type="text"],
    textarea,
    select {
      width: 100%;
      padding: 0.625rem 0.75rem;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      transition: border-color 0.15s ease;
    }

    input[type="text"]:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: #0066cc;
      box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.1);
    }

    .form-check {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .form-check input {
      width: auto;
    }

    .form-check label {
      margin-bottom: 0;
      font-weight: normal;
    }

    .radio-group {
      margin-top: 0.5rem;
    }

    .signature-field .signature-box {
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-bottom: 0.5rem;
    }

    .signature-field canvas {
      display: block;
      cursor: crosshair;
    }

    .form-actions {
      margin-top: 2rem;
      padding-top: 1.5rem;
      border-top: 1px solid #e0e0e0;
      display: flex;
      gap: 1rem;
    }

    .btn {
      padding: 0.625rem 1.25rem;
      font-size: 1rem;
      font-weight: 500;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.15s ease;
    }

    .btn-primary {
      background-color: #0066cc;
      color: white;
    }

    .btn-primary:hover {
      background-color: #0052a3;
    }

    .btn-secondary {
      background-color: #e0e0e0;
      color: #333;
    }

    .btn-secondary:hover {
      background-color: #d0d0d0;
    }

    .btn-small {
      padding: 0.375rem 0.75rem;
      font-size: 0.875rem;
    }

    footer {
      margin-top: 3rem;
      padding-top: 1rem;
      border-top: 1px solid #e0e0e0;
      text-align: center;
      color: #999;
      font-size: 0.875rem;
    }

    /* Schema content styles */
    .schema-content-form {
      margin-top: 1rem;
    }

    .content-rule {
      border: none;
      border-top: 1px solid #ccc;
      margin: 1.5rem 0;
    }

    .spacer {
      display: block;
    }

    /* Inline field styles */
    .inline-field {
      margin-bottom: 1rem;
    }

    .inline-field label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: #333;
    }

    .inline-field-horizontal {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .inline-field-horizontal label {
      display: inline-block;
      margin-bottom: 0;
      flex-shrink: 0;
    }

    .inline-field input[type="text"],
    .inline-field select,
    .inline-field textarea {
      padding: 0.5rem;
      font-size: 0.9rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .inline-field select {
      min-width: 120px;
    }

    /* Content table styles */
    .table-label {
      font-weight: 600;
      margin: 1.5rem 0 0.5rem 0;
      color: #333;
    }

    .content-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 1.5rem;
      font-size: 0.9rem;
    }

    .content-table th,
    .content-table td {
      border: 1px solid #ccc;
      padding: 0.5rem;
      text-align: left;
    }

    .content-table th {
      background-color: #f5f5f5;
      font-weight: 600;
      color: #333;
    }

    .content-table td {
      vertical-align: middle;
    }

    .table-input {
      width: 100%;
      padding: 0.375rem 0.5rem;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-size: 0.85rem;
      box-sizing: border-box;
    }

    .table-input:focus {
      outline: none;
      border-color: #0066cc;
    }

    .table-select {
      width: 100%;
      padding: 0.375rem 0.5rem;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-size: 0.85rem;
      background: white;
      box-sizing: border-box;
    }

    .table-select:focus {
      outline: none;
      border-color: #0066cc;
    }

    /* Admonition styles */
    .admonition {
      border-radius: 4px;
      padding: 1rem;
      margin: 1rem 0;
      border-left: 4px solid;
    }

    .admonition-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .admonition-content {
      font-size: 0.95rem;
    }

    .admonition-info {
      background-color: #e7f3ff;
      border-color: #0066cc;
    }

    .admonition-info .admonition-title {
      color: #0066cc;
    }

    .admonition-warning {
      background-color: #fff8e6;
      border-color: #f0a000;
    }

    .admonition-warning .admonition-title {
      color: #b07800;
    }

    .admonition-note {
      background-color: #f0f0f0;
      border-color: #666;
    }

    .admonition-note .admonition-title {
      color: #333;
    }

    .admonition-tip {
      background-color: #e6f7e6;
      border-color: #28a745;
    }

    .admonition-tip .admonition-title {
      color: #1e7e34;
    }

    .admonition-danger {
      background-color: #ffebee;
      border-color: #dc3545;
    }

    .admonition-danger .admonition-title {
      color: #c82333;
    }

    @media print {
      body {
        background: white;
      }
      .container {
        padding: 0;
      }
      .form-actions {
        display: none;
      }
      .content-table {
        page-break-inside: avoid;
      }
    }
  `;
}

/**
 * Get form JavaScript
 */
function getFormScripts(): string {
  return `
    document.addEventListener('DOMContentLoaded', function() {
      // Handle signature canvases
      document.querySelectorAll('.signature-field canvas').forEach(function(canvas) {
        const ctx = canvas.getContext('2d');
        let drawing = false;

        canvas.addEventListener('mousedown', function(e) {
          drawing = true;
          ctx.beginPath();
          ctx.moveTo(e.offsetX, e.offsetY);
        });

        canvas.addEventListener('mousemove', function(e) {
          if (drawing) {
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();
          }
        });

        canvas.addEventListener('mouseup', function() {
          drawing = false;
          // Save signature data to hidden input
          const input = document.getElementById(canvas.id.replace('_canvas', ''));
          if (input) {
            input.value = canvas.toDataURL();
          }
        });

        canvas.addEventListener('mouseleave', function() {
          drawing = false;
        });
      });

      // Handle clear signature buttons
      document.querySelectorAll('.clear-signature').forEach(function(btn) {
        btn.addEventListener('click', function() {
          const canvasId = this.dataset.canvas;
          const canvas = document.getElementById(canvasId);
          if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const input = document.getElementById(canvasId.replace('_canvas', ''));
            if (input) {
              input.value = '';
            }
          }
        });
      });

      // Handle form submission
      document.querySelectorAll('form').forEach(function(form) {
        form.addEventListener('submit', function(e) {
          e.preventDefault();
          const formData = new FormData(form);
          const data = Object.fromEntries(formData.entries());
          console.log('Form submitted:', data);
          alert('Form submitted! Check console for data.');
        });
      });
    });
  `;
}

/**
 * Escape HTML special characters
 */
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  };
  return text.replace(/[&<>"']/g, (char) => map[char]);
}

/**
 * Save HTML to file
 */
export async function saveHtml(html: string, outputPath: string): Promise<void> {
  await mkdir(dirname(outputPath), { recursive: true });
  await writeFile(outputPath, html);
}

/**
 * Generate and save HTML in one step
 */
export async function generateAndSaveHtml(
  options: HtmlGeneratorOptions,
  outputPath: string
): Promise<void> {
  const html = await generateHtml(options);
  await saveHtml(html, outputPath);
}
