/**
 * HTML Generator
 * Creates HTML documents with interactive forms
 */

import { writeFile, mkdir, readFile } from 'fs/promises';
import { dirname, resolve } from 'path';
import { existsSync } from 'fs';
import type { ParsedFormSchema, NormalizedFormField, HtmlConfig } from '../../types/index.js';
import { DEFAULT_CONFIG } from '../../types/index.js';
import type { ParsedMarkdown } from '../../parsers/index.js';

export interface HtmlGeneratorOptions {
  markdown?: ParsedMarkdown;
  schema?: ParsedFormSchema | null;
  config?: Partial<HtmlConfig>;
}

/**
 * Generate HTML document
 */
export async function generateHtml(options: HtmlGeneratorOptions): Promise<string> {
  const { markdown, schema, config = {} } = options;

  const htmlConfig: Required<HtmlConfig> = {
    ...DEFAULT_CONFIG.html,
    ...config,
  };

  let html = '';

  // Check if custom template is provided
  if (htmlConfig.template && existsSync(htmlConfig.template)) {
    html = await readFile(htmlConfig.template, 'utf-8');
    // Replace placeholders in template
    html = html.replace('{{title}}', markdown?.title || schema?.form.title || 'Document');
    html = html.replace('{{content}}', markdown?.html || '');
    if (schema) {
      html = html.replace('{{form}}', generateFormHtml(schema));
    }
  } else {
    // Generate default HTML
    html = generateDefaultHtml(markdown, schema, htmlConfig);
  }

  return html;
}

/**
 * Generate default HTML document
 */
function generateDefaultHtml(
  markdown: ParsedMarkdown | undefined,
  schema: ParsedFormSchema | null | undefined,
  config: Required<HtmlConfig>
): string {
  const title = markdown?.title || schema?.form.title || 'Document';

  let styles = '';
  if (config.embedStyles) {
    styles = `
    <style>
      ${getDefaultStyles()}
    </style>`;
  }

  let scripts = '';
  if (config.includeJs && schema) {
    scripts = `
    <script>
      ${getFormScripts()}
    </script>`;
  }

  const formHtml = schema ? generateFormHtml(schema) : '';
  const contentHtml = markdown?.html || '';

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(title)}</title>
  ${styles}
</head>
<body>
  <div class="container">
    <header>
      <h1>${escapeHtml(title)}</h1>
      ${schema?.form.version ? `<span class="version">v${escapeHtml(schema.form.version)}</span>` : ''}
    </header>

    <main>
      ${contentHtml}

      ${formHtml ? `
      <form id="form-${schema?.form.id || 'main'}" class="form">
        ${formHtml}
        <div class="form-actions">
          <button type="submit" class="btn btn-primary">Submit</button>
          <button type="reset" class="btn btn-secondary">Reset</button>
        </div>
      </form>
      ` : ''}
    </main>

    <footer>
      <p>Generated by markdown-2pdf</p>
    </footer>
  </div>
  ${scripts}
</body>
</html>`;
}

/**
 * Generate HTML for form fields
 */
function generateFormHtml(schema: ParsedFormSchema): string {
  const fieldsByPage: Map<number, NormalizedFormField[]> = new Map();

  // Group fields by page
  for (const field of schema.fields) {
    const pageFields = fieldsByPage.get(field.page) || [];
    pageFields.push(field);
    fieldsByPage.set(field.page, pageFields);
  }

  let html = '';

  // Generate HTML for each page
  for (const [pageNum, fields] of fieldsByPage) {
    if (fieldsByPage.size > 1) {
      html += `<fieldset class="form-page" data-page="${pageNum}">\n`;
      html += `  <legend>Page ${pageNum}</legend>\n`;
    }

    for (const field of fields) {
      html += generateFieldHtml(field);
    }

    if (fieldsByPage.size > 1) {
      html += `</fieldset>\n`;
    }
  }

  return html;
}

/**
 * Generate HTML for a single field
 */
function generateFieldHtml(field: NormalizedFormField): string {
  const requiredAttr = field.required ? ' required' : '';
  const requiredMark = field.required ? '<span class="required">*</span>' : '';

  switch (field.type) {
    case 'text':
      return `
      <div class="form-group">
        <label for="${field.name}">${escapeHtml(field.label)}${requiredMark}</label>
        <input type="text" id="${field.name}" name="${field.name}"
          ${field.maxLength ? `maxlength="${field.maxLength}"` : ''}
          ${field.placeholder ? `placeholder="${escapeHtml(field.placeholder)}"` : ''}
          ${typeof field.default === 'string' ? `value="${escapeHtml(field.default)}"` : ''}
          ${field.readOnly ? 'readonly' : ''}
          ${requiredAttr}>
      </div>`;

    case 'textarea':
      return `
      <div class="form-group">
        <label for="${field.name}">${escapeHtml(field.label)}${requiredMark}</label>
        <textarea id="${field.name}" name="${field.name}"
          ${field.maxLength ? `maxlength="${field.maxLength}"` : ''}
          ${field.placeholder ? `placeholder="${escapeHtml(field.placeholder)}"` : ''}
          ${field.readOnly ? 'readonly' : ''}
          rows="5"
          ${requiredAttr}>${typeof field.default === 'string' ? escapeHtml(field.default) : ''}</textarea>
      </div>`;

    case 'checkbox':
      return `
      <div class="form-group form-check">
        <input type="checkbox" id="${field.name}" name="${field.name}"
          ${field.default === true ? 'checked' : ''}
          ${field.readOnly ? 'disabled' : ''}>
        <label for="${field.name}">${escapeHtml(field.label)}${requiredMark}</label>
      </div>`;

    case 'radio':
      const radioOptions = (field.options || []).map((opt, index) => `
        <div class="form-check">
          <input type="radio" id="${field.name}_${index}" name="${field.name}" value="${escapeHtml(opt.value)}"
            ${field.default === opt.value ? 'checked' : ''}
            ${field.readOnly ? 'disabled' : ''}>
          <label for="${field.name}_${index}">${escapeHtml(opt.label)}</label>
        </div>`).join('');

      return `
      <div class="form-group">
        <label>${escapeHtml(field.label)}${requiredMark}</label>
        <div class="radio-group">
          ${radioOptions}
        </div>
      </div>`;

    case 'dropdown':
      const selectOptions = (field.options || []).map(opt =>
        `<option value="${escapeHtml(opt.value)}" ${field.default === opt.value ? 'selected' : ''}>${escapeHtml(opt.label)}</option>`
      ).join('\n          ');

      return `
      <div class="form-group">
        <label for="${field.name}">${escapeHtml(field.label)}${requiredMark}</label>
        <select id="${field.name}" name="${field.name}"
          ${field.readOnly ? 'disabled' : ''}
          ${requiredAttr}>
          <option value="">-- Select --</option>
          ${selectOptions}
        </select>
      </div>`;

    case 'signature':
      return `
      <div class="form-group signature-field">
        <label for="${field.name}">${escapeHtml(field.label)}${requiredMark}</label>
        <div class="signature-box">
          <canvas id="${field.name}_canvas" width="400" height="100"></canvas>
          <input type="hidden" id="${field.name}" name="${field.name}">
        </div>
        <button type="button" class="btn btn-small clear-signature" data-canvas="${field.name}_canvas">Clear</button>
      </div>`;

    default:
      return `<!-- Unknown field type: ${field.type} -->`;
  }
}

/**
 * Get default CSS styles
 */
function getDefaultStyles(): string {
  return `
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f5f5f5;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      background: white;
      min-height: 100vh;
    }

    header {
      margin-bottom: 2rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }

    header h1 {
      font-size: 1.75rem;
      color: #1a1a1a;
    }

    .version {
      color: #666;
      font-size: 0.875rem;
    }

    main {
      margin-bottom: 2rem;
    }

    main h2 {
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-size: 1.25rem;
      color: #333;
    }

    main p {
      margin-bottom: 1rem;
      color: #555;
    }

    .form {
      margin-top: 2rem;
    }

    .form-page {
      margin-bottom: 2rem;
      padding: 1.5rem;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
    }

    .form-page legend {
      padding: 0 0.5rem;
      font-weight: 600;
      color: #666;
    }

    .form-group {
      margin-bottom: 1.25rem;
    }

    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: #333;
    }

    .required {
      color: #dc3545;
      margin-left: 0.25rem;
    }

    input[type="text"],
    textarea,
    select {
      width: 100%;
      padding: 0.625rem 0.75rem;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      transition: border-color 0.15s ease;
    }

    input[type="text"]:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: #0066cc;
      box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.1);
    }

    .form-check {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .form-check input {
      width: auto;
    }

    .form-check label {
      margin-bottom: 0;
      font-weight: normal;
    }

    .radio-group {
      margin-top: 0.5rem;
    }

    .signature-field .signature-box {
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-bottom: 0.5rem;
    }

    .signature-field canvas {
      display: block;
      cursor: crosshair;
    }

    .form-actions {
      margin-top: 2rem;
      padding-top: 1.5rem;
      border-top: 1px solid #e0e0e0;
      display: flex;
      gap: 1rem;
    }

    .btn {
      padding: 0.625rem 1.25rem;
      font-size: 1rem;
      font-weight: 500;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.15s ease;
    }

    .btn-primary {
      background-color: #0066cc;
      color: white;
    }

    .btn-primary:hover {
      background-color: #0052a3;
    }

    .btn-secondary {
      background-color: #e0e0e0;
      color: #333;
    }

    .btn-secondary:hover {
      background-color: #d0d0d0;
    }

    .btn-small {
      padding: 0.375rem 0.75rem;
      font-size: 0.875rem;
    }

    footer {
      margin-top: 3rem;
      padding-top: 1rem;
      border-top: 1px solid #e0e0e0;
      text-align: center;
      color: #999;
      font-size: 0.875rem;
    }

    @media print {
      body {
        background: white;
      }
      .container {
        padding: 0;
      }
      .form-actions {
        display: none;
      }
    }
  `;
}

/**
 * Get form JavaScript
 */
function getFormScripts(): string {
  return `
    document.addEventListener('DOMContentLoaded', function() {
      // Handle signature canvases
      document.querySelectorAll('.signature-field canvas').forEach(function(canvas) {
        const ctx = canvas.getContext('2d');
        let drawing = false;

        canvas.addEventListener('mousedown', function(e) {
          drawing = true;
          ctx.beginPath();
          ctx.moveTo(e.offsetX, e.offsetY);
        });

        canvas.addEventListener('mousemove', function(e) {
          if (drawing) {
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();
          }
        });

        canvas.addEventListener('mouseup', function() {
          drawing = false;
          // Save signature data to hidden input
          const input = document.getElementById(canvas.id.replace('_canvas', ''));
          if (input) {
            input.value = canvas.toDataURL();
          }
        });

        canvas.addEventListener('mouseleave', function() {
          drawing = false;
        });
      });

      // Handle clear signature buttons
      document.querySelectorAll('.clear-signature').forEach(function(btn) {
        btn.addEventListener('click', function() {
          const canvasId = this.dataset.canvas;
          const canvas = document.getElementById(canvasId);
          if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const input = document.getElementById(canvasId.replace('_canvas', ''));
            if (input) {
              input.value = '';
            }
          }
        });
      });

      // Handle form submission
      document.querySelectorAll('form').forEach(function(form) {
        form.addEventListener('submit', function(e) {
          e.preventDefault();
          const formData = new FormData(form);
          const data = Object.fromEntries(formData.entries());
          console.log('Form submitted:', data);
          alert('Form submitted! Check console for data.');
        });
      });
    });
  `;
}

/**
 * Escape HTML special characters
 */
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  };
  return text.replace(/[&<>"']/g, (char) => map[char]);
}

/**
 * Save HTML to file
 */
export async function saveHtml(html: string, outputPath: string): Promise<void> {
  await mkdir(dirname(outputPath), { recursive: true });
  await writeFile(outputPath, html);
}

/**
 * Generate and save HTML in one step
 */
export async function generateAndSaveHtml(
  options: HtmlGeneratorOptions,
  outputPath: string
): Promise<void> {
  const html = await generateHtml(options);
  await saveHtml(html, outputPath);
}
